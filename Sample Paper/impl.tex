\subsection{Implementation}

We now discuss the implementation of 1) the malicious SDN app used to
simulate spoofed packets from a compromised switch that lead to fake 
packet\_in messages being sent to the controller and 2) \name, our 
network reconnaissance detection SDN app. The implementation is based on
the design discussed in the previous section. We have used 
POX~\cite{poxWiki} as the SDN controller, which is a Python-based SDN
controller, and both the malicious and detection SDN apps are
implemented in python. 

\myparagraph{Malicious App} The malicious SDN app is implemented as a
single python file. After being registered with the POX controller, it
first reads the IP addresses of the host(s) being used to create the
reconnaissance packets on behalf of a compromised switch. It then
registers an event listener for packet\_in messages from switches. For
each packet\_in event, it checks if the source IP address matches any
IP in the malicious hosts list. If a match is found, the malicious app
arbitrarily changes the event's physical port number to a random value,
simulating a spoofed packet created from a compromised switch. The app
then fires a custom event, using the capabilities of the event manager
provided by POX, and forwards the changed packet information as the 
custom event argument. Other SDN apps running in the application plane 
register their handlers for the new custom event instead of the 
packet\_in event and receive the new message from the malicious app. If
the source IP is not matched to a malicious host then the malicious app
does not change the event source port and passes the unmodified message
to the other apps in the custom event. The apps listening for this
custom event then process the packet and decide an action to be taken
for the current message.

\myparagraph{Detection App} The detection SDN app is implemented as a
single python file in over 530 lines of source code. The detection app
first registers with the controller and waits for the switches to 
connect to the controller by registering a handler for the 
connection\_up event, which is raised whenever a new switch connects to
the controller. When such an event occurs, the detection app uses the 
discovery module from POX to send control messages requesting switches 
broadcast LLDP packets. This allows the detection app to learn about the
configuration of switches in the network and the links between different
switches. The app then creates separate objects for each switch and 
maintains information about which physical ports on a given switch are
connected to another switch. 

The app also registers a handler for the custom event fired by the 
malicious app in response to any packet\_in message from the switches. 
This handler maintains logic for the forwarding of packets and then also
builds the mapping of hosts and switches to physical ports they are 
connected to for each of the switches. This mapping is referred to as 
the local map. When the forwarding logic instructs a switch to flood a
packet, that information is added to an ephemeral flood map. This flood
map is pruned on a fixed interval preventing the lookup from getting too
large.

Using the data structures created from the forwarding logic, the handler 
asynchronously calls a validation function, passing the packet information
to the validation function as an argument. The validation function 
extracts the flow information and looks at the local map and flood map to 
find any previous event that may lead to the generation of the current 
packet\_in message. First looking at the local map, the app learns if
the physical port, on which the new packet was received, is connected to
another switch or a host. If the local map reports the event port is 
connected to a host it verifies the source IP matches the expected IP
address for that switch's physical port. If the event port is connected
to another switch, it then does a look up in its ephemeral flood map to 
see if the previous switch was instructed to flood the packet generating
the packet\_in message. If the lookup to the flood map fails, the app then 
uses the NBI to request flow statistics from the switches, which it
listens for by registering a handler for a flow\_stats\_received event.
Once the flow stats are received by the app, the validate function
iterates through the flow entries on the previous switch looking for a 
flow that forwarded the packet to the current switch. If a matching flow
cannot be found, the packet\_in message is flagged along with the 
corresponding switch. During the processing of the packet\_in messages
the app does not block, so any other apps trying to perform operations
in response to the event can go perform their tasks without interruption.
